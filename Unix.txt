
==1. Introduction==
21. 함수간 함수의 데이터 공유는 스택이 아니라 힙을 사용해야 함.
22. 이후는 '3. Malloc' 파일과 내용 겹침


==2. Unix==
13. 이후 중복

==3. Malloc==

36. malloc()가 시스템콜 함수인 sbrk()를 호출해도 sbrk는 주소공간을 늘리고 줄일 뿐 memory management 기능은 없음. 이는 process가 관리하도록 맡김.   
48.  어떤 일 진행하다 점프하려면 지금일 다음 일의 주소를 기억해야함. 원래 갖고 있던 저장소의 시작위치를 기억해야함. fp :  저장소 시작주소 보관. RET이 스택 맨 위(다음에 해야할 일)를 자동으로 pc레지스터로 옮겨줌. 그래서 일 하다 점프하려면  stack에 먼저 리턴주소를 넣어야 함. pop fp 는 스택에 있는 걸 잡아서 fp에 옮기겠다는 뜻. push fp는 top이 가리키는 곳으로 fp를 push 한다는 뜻. 즉: 점프할때 리턴할 주소를 스택에 넣고 내가 관리하고 있는 주소를 넣음. 리턴값은 특정 레지스터에 넣음 
- 밑에서 부터 리턴주소->스택프레임->스택변수들 순으로 스택에 쌓는다. 내 스택은 보관하기 위해 fp에 저장.  


==Process Control part 1 kor== 

- 프로그램 내부에서만 데이터를 저장하고 관리할 필요가 있다면, `malloc()`이나 지역 변수를 사용하는 것이 적합합니다.
- 여러 프로세스가 동일한 데이터에 접근하고 이를 공유할 필요가 있을 때는 공유 메모리를 사용하는 것이 바람직합니다.

==11. How to use Shared Memory==

6. shared memory의 key로는 아이디를 사용
- 파일에 쓰고 공유하는 방법
- 경로명과 추가적인 id로 정보를 공유
-  header 파일에 샵 인클루드로 넣는 것

8. 서브 프로세스는 최초로 채팅에 들어온게 fork로 생성
11. 넘어감

==14. Chatting Forker==

4. thread 구현 후 전역변수로 공유함 (포인터 사용해도 되나 번거로움). 
5. thread는 wait대신 join 사용. pthread_create는 포인터를 이용해서 return 해줌.
6. 이번 과제는 프로세스 2개로 출력과 입력, 차후엔 thread로 구현. processs는 전역으로 공유 x, thread는 전역으로 공유함.
9. structure로 만들거나, 입력용 and 출력용 shared memory를 따로 만들어도 가능.

==15. Chatting Semaphore Signal Secured==

2. 두 개 이상 프로세스가 write 할 때만 race condition을 고려하면 됨.
4. semget에 1은 한 명만 허용한다는 뜻.
6. semaphore는 이름을 가지는데 이를 파일로 처리하면 됨. nameless semaphore도 있음. 경쟁은 다른 프로세스와의 경쟁 또는 본인의 자식과의 경쟁이 있을 수 있음. 해당코드는 1씩 감소시킴.
10. 비정상종료시 signal(event)가 날라옴 -> handler(call back function)가 처리함. 
12. signal 발생하면 sigint로 가고 이는 sigint_handler가 관리.
13. 이후 넘어감


==19. IPC ==
2. process 죽을때 ipc도 제거되진 않음. 필요하면 유저가 제거해줘야함 (공유메모리나 공유세마포어는 누가 접근할지 모르니 os가 제거 해주진 않음). process당 process control table (pcb)를 가짐 (더블링크드리스트로 구현됨). process가 죽으면 os가 이 링크들을 다 끊음. 앞으로 posix의 semaphore와 thread를 사용함. 나머지를 기다리게 하려면 semaphore 값들을 다 0으로 설정해놓으면 됨 (*시험* )
- IPC 테크닉 종류
- 1. 파이프라인 :표준 출력을 표준 입력으로 연결 (단방향의 문제점 가짐, 구현 편함)
- 2. 세마포어
- 3. 공유메모리
- 4. 메세지큐 (개수 제한이란 단점)
- 5. 네트워크를 통한 소켓 (서버-클라 두고 주소를 127.0.1인 자기자신에게 보내면 됨)

5. ipc_private으로 key를 만들 수 있음 (접근하게 하진 않고 만들기만 함 -> 보안성 높음). 해당 프로세스 안에서만 사용되는 듯 -> 부모자식간. 다중프로세스로 짜지 않을거면 다 컴파일 해서 하나의 프로세스로 만들거나 모두를 다 독립으로 만들고 DB가 동기화 되게 하는 방법이 있음. exec로 아이디를 넘겨주면 공유가 가능함. 
6. 프로그램 헤더파일에 key를 정의. 
12. ipc는 file system 와 달리 reference count(몇 개의 프로세스가 자신을 참조하는지)가 없어 삭제를 못 함. 
- Buffered io / non-Buffered io
- synchronized io / asynchronized io 
- blocking io / unblocking io
- multiplex io : mux io 존재를 계속 확인함 이를 polling이라 함
15. *Semaphore* : 공유 가능한 자원의 수. 접근하면 1 감소 돌려주면 1 증가 시켜 줌. semaphore = 1인데 wait()를 4번 한다면 0, -1, -2, -3 가 되고 그 뒤에 post() 2번 부르면 -2, -1이 됨. 무한히 감소하는지 0에서 stop하는지 확인해야함. 
16. signal(=post).

77. ~일단 넘어감. 
- *시험* : 곰이 뮤텍스에 들어가면 뮤텍스는 0됨. 근데 full = 0이니 기다림. 꺠워줄 수 있는 벌은 뮤텍스가 0이라 들어가질 못함 -> dead lock -> 돌아갈 수 있도록 고치기. 두번째 예제는 둘다 0이라 둘 다 못 들어감.


==21. Threads Part 1==

9. posix pthread 쓰려면 옵션 'l' 써야함. 
11. thread는 비동기 io 처리하기 위해 사용됨. fgets하는 동안은 기다리고 있으니 입력받는 스레드와 출력하는 스레드를 따로 만들어서 동시에 돌아가도록 만드는 듯. 리스폰스 타이밍을 줄이기 위해 상호작용하는 프로그램에 유용함.

-  basicpthread 파일 : pthread_create 는 thread1 정보를 하나 만들고 구조체에 넣음. 메세지 넣는 곳은 시작주소를 넣는데 여러개 메세지 넘기고 싶으면 구조체로 만들어서 구조체의 시작주소 넘겨주면 됨. void타입인 이유는 어떤 타입이 올지 모르니 c컴파일러가 컴파일하는 순간 type casting을 해줌. thread1과 2간 누가 먼저 실행되는지, 누가 먼저 죽는지 모르는 듯. main, t1, t2 총 3개의 스레드가 있음. main이 죽으면 스택이 날라가니 메세지들도 다 날라감으로 thread들이 access 할게 없음. 그래서 join을 통해 메인을 기다리게 해서 t1, t2와 합류되도록 함.  join 하기 전에 생성된 t1, t2가 먼저 종료될 수 있음 -> 동기화 시켜야하는데 sleep 시켜놔도 구현 가능. 스레드가 메인 스택을 쓰는건 좀 위험하기에 보통 전역으로 선언해서 전역스택을 씀.   

14. pthread_self()는 본인 스레드 id 알고 싶을 때 사용. 
16. 프로세스는 thread의 정보를 갖고 있는데 스레드가 죽어서 detach 할 때 detachsate를 사용함. thread가 차지한 자원을 돌려준다. 
19. thread가 main공간을 쓰는데 메인이 먼저 죽을 수 있음 join을 호출하지 않아서. main도 스레드임 (그래서 스레드와 process id는 같고 thread id는 다름).
24. 옛날 얘기임.
25. thread 종료의 3가지 방식
28. return도 포인터 타입으로 해줌
29. 뒤에 넘어감.


==23. Thread Part 3==

25. condition variable이 필요한 상황 슬라이드. mutex는 잠구고 푸는 기능만 한다. sleep 되기전에 잠군걸 풀어야 다른 애들이 들어올 수 있음.. 맨 마지막 자원 이용한 애가 다시 꺠워줌. 
34. 꿀이 가득 안 찼으면 기다려야하는 조건이 있음 -> condition wait. 채우는 애는 채울때 lock하고 나올때 unlock, 다 채웠으면 signal -> condition signal. signal 받으면 unlock -> lock이 됨. lokc 치고 들어갔다가 조건 안 맞으면 자동으로  unlock 됨. 


==25. Signal Part1==

2. signal은 비동기 신호를 처리함. 핸들러가 함수포인터를 전달해줌
3. V: violation. 시그 폴트가 생기면 현 메모리 상태를 저장하는 core 파일이 생성됨. SIGURG -  급한 메세지를 바로 처리할 수 있게끔 함.  유닉스는 kill을 명령어로도 주고 함수로도 줌. kill(1) : 명령어, kill(2) : 함수임. 
- mysigalarm.c :  ps -ef | grep "mysig" 하면 알림 보내는 mysig 파일 종료시킬수 있음. 
- real time : deadlinen 내에 끝마침을 보장해주는 것. 
- os를 정의하는 방식 : premptive / non premptive, real time / non real time
- utilization = busy time / 관측 시간. 완료된 task의 수와 같은 throughput이 좋아야 좋은 시스템이다. 
- repsonse time : 프로그램 시작~끝 시간. response itme을 줄이려면 thread를 사용하고 실행시간이 짧은것부터 시작시키는게 더 줄어듬. 

5. 프로세스의 존재 여부를 판단할때 signal 0을 씀
7. 시그널 action 3가지.
12. child가 죽을때 SIGCHLD 보냄. 이 시그널을 못 잡으면 zombie가 됨. SIGCONT : 중지된 시그널 재개
13. no hup
14. hangup signal 보내면 다 죽음. 
19. ~22 넘어감
23. 사용자 정의 시그널. 리턴은 void 포인터. 인자로 int와 함수를 받음. 이 함수도 타입이 void 포인터이고 인자는 int를 받음. 이전 signal handler의 주소를 리턴하기위해 void 포인터를 리턴함.
24. sigfunc라는 타입을 만듦. 리턴 void이고 인자로 int 받음.  
    `sigfunc * signal (int, sigfunc * )` 형태가 됨.  어떤걸 넣으면 넣은것의 리턴이 그대로 나온다는 뜻(?). 
- myalarm.c 에서 Sigfunc 대신 (void * ) 앞에 붙이고 맨 뒤에 (int) 붙인것과 같은 뜻임.  main안에 1은 포인터 1임. 함수를 상수로 맵핑(정의) 할 수 있음 (define). '-1, 0, 1'은 커널이 관리, 접근 할 수 있음. 메인에서 2번 시그널 오면 signo에 2번 넣고 2번 배열에 signal_handler 넣으면됨. 

25. mask 필드를 block 시키면 시그널 발생 안함.  ctrl c로 빠져나오게 하려면 login과 count를 감소시키면 됨.   


----
----


==4. File System== 
2. 디바이스 드라이버가 물려있는 파트(캐릭터 디바이스, 블록디바이스로 구성). 이는 파일 서브시스템에 물려있고 이는 프로세스에 물려있음.
3. 링크드리스트로 파일 연결시 reliability와 탐색 속도에서 불리함. 대신 데이터 넣고 관리하긴 쉬움. 유닉스는 인덱싱을 통해 탐색을 빨리하게 함. 이걸 테이블로 관리할지 트리로 관리할지는 결정해야 함. 파일을 일정한 크기의 블록으로 나눠서 관리. 공간 나눌때 fragmentation 발생하긴 함.  
4. Disk 1, 2 각각에 /dev/sda 1, 2가 나뉘어 담겨있음. 하나의 디스크가 하나의 block group을 형성하는 듯.
5. superblock은 위 block group 중 파일시스템에서 가장 먼저 읽히는 첫 번째 자리에 위치한 블록 (파일시스템 타입, data block과 indoes의 개수, inode 태이블의 시작 정보를 담음). 
6. indirect 1개 블럭 크기 계산 예시. standard error 2번은 unbuffered임. open은 3번, 0은 standard in, 1인 standard out. 
7. indirect n개 블럭 크기 계산 예시. FAT : file allocation table. sequential allocation에는 테이프 같은게 있다. 
8. inode 테이블은 파일디스크에 저장되어있음. datablocks는 4096바이트씩 나눠져있음. 즉 한 아이노드당 4096 가리킴. 데이터블록의 한 블록을 아이노드로 쓰기도 함 (대용량 저장시). 
9. sdb : 이동디스크. 
15. 섹터와 아이노드로 저장위치를 계산할 수 있다.
16. file a, b가 디스크 블록임. 3개 필요하니 아이노드 테이블을 가리킴. 
17. 1024로 정의. 대용령아묜 double indirect pointers 사용. 
18. (직접 포인터는 12개이고 더 크면 12+1024) * 4로 할당. 
19. 한 아이노드안에 다이렉트 블록이 들어가있음. 
20. inode-table은 data block 위치를 담고있음. 
22. triple 구조면 저렇게 나옴. 
23. 데이터가 다음 위치를 가리키는 방식(예전방식). 그래서 EOF가 있음. 
24. 16비트면 다음과 같은 엔트리와 블록을 가질 수 있음. 
25. 블록의 시작번지만 저장해놓으면 다음 읽을 것들은 연결되어 있으니 따라가며 읽으면 됨. 
26. 디렉토리 블럭은 파일네임과 inode만 저장. reference counter는 2가 됨. 
27. usr/lib은 7글자니까 7바이트로 처리됨. 
29. mkdir : directory이니 파일에 저장하고 이는 directory block에 저장. 현재 디렉토리는 1267일때 mkdir testdir 하면 testdir이 2549이다. 그렇다면 현재 디렉토리에는 현재디렉토리, 부모디렉토리, 하위디렉토리가 있음. 2549에 가면 현재는 2549가 되고 부모는 1267이다. 

==6. Standard IO==
2. fopen하면 파일 구조체에 대한 포인터를 줌. 매개변수로 stdout이라고 하면 stdout은 모니터에 출력하는 standard임으로 모니터에 출력됨. 
7. 첫예에서 라인개행 만나면 출력됨. 두번째 예는 no buffer이니까 sleep(1) 후에 바로 출력됨. sleep이 버퍼링 되는걸 막아줌. parent에 출력 안된 내용이 버퍼에 남아있을때 child에도 그 버퍼가 복사 되는지 확인해야함. 
8. 한 시스템에서 다른 시스템 호출하는 방법 : 시스템콜 호출하는 방법 (ls 를 하면 하고 나서 나한테 제어권이 돌아옴). exe를 사용하는방법(제어권을 넘겨줌). exec하면 file discripter table은 날아감. close_on_exec 플래그를 설정하면 exec 호출할때 close 할 것들을 설정할 수 있음.
12. shell과 shell 이 실행시킨 프로세스는 독립이라 프로세스가 죽으면 파일 디스크립터와 파일 테이블이 날라가도 shell에 영향을 끼치진 않음. 
15. 매크로는 스택에 넣거나 빼거나 하는 오버헤드가 없어서 더 빠름.
21. rewind(fp) 처음으로 돌아감. 
31. ~30 넘어감. 
- read.c : 엔터 칠떄까지 출력 안됨 -> 버퍼로 되어있음.
- myreadOnech.c : 바로 출력됨.
- nonecho.c : gets는 위험함으로 fgets로 버퍼 사이즈 줌. fgets의 stdin은 0으로 매크로심볼이 되어있음. 
- nonechogetch.c : 세팅을 바꾸면 이전 세팅을 반환함 그래서 그걸로 복원하면됨. 

==7. File IO==  
2. p1이 있고 p2가 있을때 p1이 aaa.txt에 hello를 쓰면 그만큼 offset이 이동됨 (aaa.txt에서). 근데 이  offset을 p1과 p2가 공유한다면 p2가 hi라고 치면 그 뒤에 연달아 쓰지만 공유하지 않으면 offset 0부터 오버라이트됨. 동일한 bbb.txt를 두 번 열면 두 파일은 offset을 공유하는지 *시험*나옴. 5번의 경우 부모와 child가 경쟁을 하게 됨. 
3. 첫그림은 프로세스가 독자적으로 갖고 있고 두, 세번째 그림은 운영체제가 유지하는거임. 그래서 프로세스가 죽으면 첫 그림의 내용들은 죽어서 다 free 되는거임(컴퓨터 끄면 다 날라감). 첫 그림 프로세스안에 fd가 있고 offset을 유지하는 애들은 두 번째 그림에 있음. 그것들이 다 포인터로 연결되어있음. 즉 process가 file descripter로 file table을 가리키고 이는 v-node table을 가리키는 듯
4. 각각의 파일테이블을 가지고 이들은 동잃란 v-node를 가리키고 이는 i-node를 가리킴.
5. dup()을 사용하면 애초에 동일한 파일테이블엔트리 가리킴. 그래서 동일한 파일 오프셋을 가짐.
7. 부모와 차일드는 같은 파일 오프셋을 가리킴.
8. 프로세스가 `fork()` 시스템 호출을 통해 새로운 자식 프로세스를 생성할 때, 부모 프로세스와 자식 프로세스가 동일한 파일 디스크립터를 공유하는 경우, 동기화 없이 동시에 파일에 쓰기를 시도하면 출력이 섞일 수 있다는 것을 설명합니다.
- 부모와 자식은 같은 파일 디스크립터를 공유하지만, 파일 디스크립터 테이블의 항목은 독립적입니다.
- 같은 파일 테이블 항목을 참조하므로, 파일 오프셋과 파일 상태 플래그는 공유됩니다.
14. The standard error stream, for example, is normally unbuffered so that any error messages are displayed as quickly as possible, regardless of whether they contain a newline.
15. If we don’t like these defaults for any given stream, we can change the buffering by calling either the setbuf or setvbuf function.
18. When we open an existing file or create a new file, the kernel returns a file descriptor to the process.

==8. File==  
7. disk block 얼마나 차지하는지 확인. 블락을 실제로 할당하진 않는듯.
12. pread : read한 뒤 lseek 한 것과 동일. 이 두 오퍼레이션 역할을 아토믹하게 수행함으로 중간에 인터럽트가 발생할 요소가 없는게 장점, 파일 오프셋의 변경이 없음(read와의 차이). 즉 다중 스레드 환경에서 여러 스레드가 같은 파일 디스크립터를 공유하는 경우, `pread`를 사용하면 파일 오프셋을 이동하지 않고 특정 위치에서 데이터를 읽을 수 있으므로, 동기화가 더 쉬워집니다.
20. sync : 쓰기 작업으로 수정된 블록을 큐잉함, 즉 모든 수정된 블록을 디스크에 비동기적으로 기록함 (disk에 기록 될 때 기다리지 않음, 이 함수는 시스템 데몬에 의해 주기적으로 호출됨, 커널의 블록 버퍼를 주기적으로 flushing 해줌을 보장함). 
21. `fsync` : 파일 디스크립터 `fd`로 지정된 파일의 모든 수정된 데이터를 디스크에 동기화합니다. 데이터가 디스크에 안전하게 기록될 때까지 반환되지 않습니다. 즉, 호출한 프로그램은 디스크 기록이 완료될 때까지 기다립니다. 데이터 블록뿐만 아니라 파일의 메타데이터(예: 파일 크기, 수정 시간 등)도 디스크에 기록합니다. *fdatasync* : fsync와 같은 동작을 하나, 파일의 데이터 블록을 디스크에 기록하지만, 파일의 메타데이터는 동기화하지 않습니다. 단, 파일 크기 변경과 같은 데이터 일관성에 영향을 미칠 수 있는 메타데이터는 동기화합니다. 
22. io에 대해서는 ioctl이 있고 file에는 fcntl이 있음. fcntl은 열려있는 파일의 속성을 변경함. 
23. <>이건 read, write를 동시에 한다는 뜻. 
26. 0,1,2도 파일로 맵핑되어 있음.
- fsyn는 fd로 받아서 fd에 해당하는 파일만 하드디스크에 쓰고 그냥 syn는 캐시에 있는 모든 내용을 디스크에 다 쓰는듯

==9. File-IO==    
4. MBR은 "파티션 섹터" 또는 "마스터 파티션 테이블"이라고도 불리는데, 그 이유는 하드디스크가 포맷될 때 나뉘어지는 각 파티션의 위치에 관한 정보를 가지고 있기 때문이다. MBR은 메모리에 적재될 운영체제가 저장되어 있는 파티션의 부트 블록 (boot block)를 읽을 수 있는 프로그램을 포함하고 있음.
6. 인텔의 부팅과정
15. 파일 테이블과 파일 디스크립터 테이블 차이
- 파일 디스크립터 테이블과 파일 테이블은 운영 체제에서 파일 I/O 관리를 위해 사용되는 두 가지 중요한 데이터 구조입니다. 이 두 테이블은 서로 다른 수준에서 파일 정보를 관리하고, 각기 다른 목적을 가지고 있습니다.
- 파일 디스크립터 테이블 (File Descriptor Table)
    1. **프로세스 수준의 테이블**:
    - 각 프로세스마다 고유한 파일 디스크립터 테이블을 가집니다.
    - 테이블에는 해당 프로세스가 열어 놓은 모든 파일에 대한 엔트리가 포함됩니다.
    2. **파일 디스크립터 (fd)**:
    - 파일 디스크립터는 파일 디스크립터 테이블의 인덱스로 사용됩니다.
    - 정수 값으로 표현되며, 파일 디스크립터 테이블에서 특정 파일에 대한 정보를 참조합니다.
    3. **구성 요소**:
    - **파일 디스크립터 (fd)**: 테이블의 인덱스로 사용되는 정수.
    - **파일 상태 플래그 (fd_flag)**: 파일의 상태나 접근 모드를 나타냅니다 (예: 읽기 전용, 쓰기 전용).
    - **포인터 (pointer)**: 파일 테이블의 엔트리를 가리키는 포인터.
    4. **목적**:
    - 프로세스가 열어 놓은 파일들을 관리하고, 파일 디스크립터를 통해 파일에 접근할 수 있도록 합니다.
    - 동일한 파일을 여러 번 열면, 동일한 파일 테이블 엔트리를 가리 키는 여러 파일 디스크립터 테이블 엔트리가 존재할 수 있습니다.
- 파일 테이블 (File Table)
    1. **시스템 수준의 테이블**:
    - 시스템 전체에서 열려 있는 모든 파일에 대한 정보를 유지합니다.
    - 파일 테이블은 여러 프로세스가 공유할 수 있는 파일에 대한 정보를 포함합니다.
    2. **파일 테이블 엔트리**:
    - 파일의 상태와 파일 포인터 등을 포함하는 데이터 구조입니다.
    - 파일 디스크립터 테이블의 포인터를 통해 참조됩니다.
    3. **구성 요소**:
    - **파일 상태 플래그 (file status flags)**: 파일의 상태나 접근 모드를 나타냅니다.
    - **파일 오프셋 (file offset)**: 파일 내에서 현재 읽기/쓰기 위치를 나타냅니다.
    - **inode 포인터**: 파일의 메타데이터를 포함하는 inode를 가리킵니다. (inode는 파일 시스템에서 파일의 속성 및 디스크 블록 위치 정보를 포함합니다)
    4. **목적**:
    - 시스템 전반에서 열려 있는 파일에 대한 상태 정보를 유지하고 관리합니다.
    - 여러 프로세스가 동일한 파일을 열면, 파일 테이블의 동일한 엔트리를 공유하게 됩니다.
- 파일 디스크립터 테이블 : 프로세스 수준, 프로세스가 열어 놓은 파일들을 관리, 파일 디스크립터 (fd), 파일 상태 플래그 (fd_flag), 포인터 (pointer), 특정 프로세스의 파일 디스크립터, 프로세스마다 고유하며, 다른 프로세스와 공유되지 않음, 파일 디스크립터를 통해 프로세스가 파일에 접근할 수 있도록 함
- 파일 테이블 : 시스템, 시스템 전체에서 열려 있는 파일들의 상태를 관리, 파일 상태 플래그, 파일 오프셋 (file offset), inode 포인터, 시스템 전체의 파일 상태 정보, 여러 프로세스가 동일한 파일 테이블 엔트리를 공유할 수 있음, 파일의 상태와 위치 정보를 유지하여, 여러 프로세스가 파일을 효율적으로 접근하고 공유할 수 있게 함
- 이렇게 파일 디스크립터 테이블과 파일 테이블은 각각 프로세스 수준과 시스템 수준에서 파일 관리의 역할을 담당하여, 운영 체제가 파일 I/O를 효율적으로 처리할 수 있도록 돕습니다.
19. 파일 디스크립터가 파일 테이블을 가리키고 파일테이블의 inode가 실제 disk를 가리키는 형태인듯.
25. 파일과 디렉토리의 기본 권한
- 기본적으로 새로 생성되는 파일의 최대 권한은 666 (rw-rw-rw-)입니다.
- 기본적으로 새로 생성되는 디렉토리의 최대 권한은 777 (rwxrwxrwx)입니다.
- umask 값은 기본 권한에서 빼는 방식으로 적용됩니다. 즉, 최종 권한 = 기본 권한 - umask
- umask 값 022
- 기본 파일 권한: 666 (rw-rw-rw-)
    - umask: 022 (---w--w-)
    - 결과 파일 권한: 644 (rw-r--r--)
- 기본 디렉토리 권한: 777 (rwxrwxrwx)
    - umask: 022 (---w--w-)
    - 결과 디렉토리 권한: 755 (rwxr-xr-x)
- umask 값 077
- 기본 파일 권한: 666 (rw-rw-rw-)
    - umask: 077 (----rwxrwx)
    - 결과 파일 권한: 600 (rw-------)
- 기본 디렉토리 권한: 777 (rwxrwxrwx)
    - umask: 077 (----rwxrwx)
    - 결과 디렉토리 권한: 700 (rwx------)
29. 3인 이유는 0, 1, 2는 못 쓰니까.
43. 파일 관련 동기화 문제. 만약 a라는 파일에 write하려고 하는데 동기화 문제로 다른 프로세스에서 이 파일에 대해 creat를 수행해버리면 write한 내용이 날라감.
44. `dup()` 함수는 기존 파일 디스크립터를 복사하여 새로운 파일 디스크립터를 반환합니다. 새 파일 디스크립터는 원래 파일 디스크립터와 동일한 파일을 참조하고, 동일한 파일 오프셋을 공유하며, 동일한 파일 상태 플래그를 가집니다.
46. 동일한 파일 오프셋을 공유합니다.
47. `dup2()` 함수는 기존 파일 디스크립터를 복사하여 지정된 파일 디스크립터로 덮어씁니다. 만약 `newfd`가 이미 열린 상태라면, 먼저 닫힌 후 복사됩니다. `dup2(fd, 1)`는 파일 디스크립터 `fd`를 표준 출력(`stdout` : 1번)에 복사합니다. 따라서 `printf` 출력은 `example.txt` 파일에 쓰여집니다.
51. `/dev/fd/n` 경로를 열 때의 동작이 `dup(n)` 함수를 호출하는 것과 동일한 결과를 가져온다는 의미입니다.

==10. File Directory== 
26. unlink : 파일의 연결 계수가 감소 시킴, 디렉토리 항목을 지움. 연결 계수가 0이 되면, 파일을 디스크에서 제거한다. 다른 프로세스들이 사용하고 있는 파일에 대해서는 unlink 하여 연결 계수가 0이 되더라도 사용 중이던 프로세스는 계속 접근 가능
- 디렉토리는 파일 이름과 `inode` 번호를 저장하고, `inode`는 파일의 메타데이터와 데이터 블록 포인터를 저장합니다. 데이터 블록은 실제 파일 데이터를 저장하는 구조입니다.
41. *여기서 부터 시험은 안나오는 듯*
42. 끝을 모르면 for가 아니라 recursive로 탐색함.

==12. Process Control== 
2. 안 외워도 됨
3. 부모와 자식의 차이점
5. 차일드 증가해도 패런트에 영향 안 끼침. 
12. ~13 넘어감
14. ~15도 함수 외울 필요 없다 함.
18. 차일드가 차일드를 만들자 마자 죽어버림. 그러면 차일드의 차일드는 고아가 됨. 고아의 아버지는 innit이 됨. 그래서 그 차일드는 좀비가 되지 않음 (innit이 데몬이라 안 죽고 계속 깨어있어서 sigchild 신호를 계속 받을 수 있음). 두 번째 자식 프로세스가 `sleep(2);` 동안 대기하고 있는 동안 부모 프로세스는 첫 번째 자식 프로세스가 종료된 것을 감지하고 자신의 정보를 출력하게 됩니다. 그런 다음, 두 번째 자식 프로세스가 대기 시간을 마친 후 자신의 정보를 출력합니다.

----
- 지난시간 19장 ipc파트 수업한 듯.
- 62pge MessageQueue 파트
---

==25. signal part1== 
3. kill1은 명령어, kill 2는 함수
6. 시그널 죽었는지 살았는지 확인할 때 0 씀. 
7. ignore할 수 없는 signal은 sigkill 과 sigstop임.
10. sigusr1과 sigusr2로 동기화를 이용해서 p, v operation 구현할 수 있음 *시험 나올 수 있음*
12. sigfpe, sighup
17. sigpwr
18. 뒤에 다 넘어감.

==26. signal part2==
3. 현재의 시그널 핸들러 주소를 아려면 시그널을 등록해야함. 등록이란 말은 변경을 한다는 말. 
4. 시그널을 처리하는 동안 시그널을 queuing 힘. signal은 reliable해야 함. 시그널을 등록하려는 순간에 또다른 시그널이 날라오면 처리가 안됨. 그래서 그 시그널이 오지 못하도록 블락 시켜야 함. 그래서 시그널을 등록하기전에 bit mask를 막아둬서 동기화 시켜야함.
6. 꺠우는게 없으면 계속자는 문제가 있는 듯. 
7. 여기서 부터 ~signal part3 까지 다 넘어감
16. 스택 복원 가능한 비지역적 점프를 제공함 : setjmp, longjmp. goto는 지역분기가 지원해줌. 롱점프 해서 돌아가면 이전 스택이 복원됨. return 값의 차이로 setjmp와 longjmp를 구분하는 듯. 
19. 한번은 optimize 하지 않은 결과, 한번은 한 결과. setjmp가 0이 아닌 조건은 longjmp라는 뜻임. 만약 optimize하면 volatile만 보장됨. 

==27. signal part 4==
4. 비트 연산 이용함. 
6. 시그널 멤버 등록됐는지 확인
7. 멈춰있는 상태(pending)의 시그널을 찾음.
8. signal process mask하는 이유 : 시그널 핸들러 등록하기 전에 새로운 시그널 들어오면 안되니까. 자고 일어나서 컨트롤 백슬래쉬가 펜딩됐다고 나옴. 컨트롤 백슬래쉬를 10번 눌러도 한 번만 실행됨. 그 이유는 시그널 핸들러를 처리하는 동안 새로운 백슬래쉬(시그널)가 여러개 들어와도 블락 시키기 때문임. 즉 시그널은 큐잉이 불가함. 
9. sigaction이 더 안정적임. 시험 안 나옴 
10. systemcall이 자동으로 restart하는지 봐야함. 
14. main에서 signal 2번, pr_mask, sigsetjmp한 후 pasue함. siglongjmp하면 sigsetjmp로 감. *시험나올듯* (setjmp와 longjmp를 바꿨을 때 어떻게 될지). 시그널핸들러 등록할때 시그널을 마스크하고 suspend하는듯. 시그널이 현재 블락되어 있는지 항상 확인해야함. 
- 내가 핸들러로 시그널 처리할 때 동일한 시그널이 발생하면 처리하기 힘드니 핸들러에서 시그널을 블락시킴. 만약 다른 타입의 시그널발생하면 핸들러2가 실행될 것임(이건 허용시켜줌). 핸들러2 역시 해당 타입의 시그널 + 첫 핸들러에서 블락한 시그널을 블락해줘야함. 나중에 setjump로 복원해주는 듯?
17. SIGUSR1을 보내면 그게 호출될 때 자기를 발생시킨 시그널을 block 시킴. 그래서 starting sig_usr1 : sigusr1이 찍힘. 마스킹된 상태에서 alarm이 발생하면 블록? 뭔소린지. *시험나옴*
19. suspend 하기 전에 block 한 다음에 기다림. suspend는 시그널 마스크를 reset 시켜준 후 끝나고 return 해줌. 
20. 컨트롤 c 누르면 sig_int 핸들러를 막음. 시그널 핸들러로 가기 전에 sigsuspend에서 waitmask 값으로 reset 함. 그래서 sigusr이 막아짐. &newmask는 sigint가 됨. 컨트롤 c누르면 핸들러 들어가기 전에 sigusr1을 suspend로 막아 놨기 때문에 시그널끼리 중첩되는걸 막음. suspend를 빠져나오면 이전 시그널 마스크를(SIGINT를) 복구한다. 그래서 sigint가 찍힘. 그 후 oldmask로 마스킹함 (올드마스크는 아무것도 지정되지 않았음). 그래서 찍으면 아무것도 출력되지 않는 듯. 
21. SIGQUIT으로 마스킹 (시그큇을 막음). quitflag == 0이면 계속기다리는데 이때 zeromask(아무것도 없음)는 모든 시그널을 받아들인다는 뜻(이 아니라 mask에 아무런 시그널을 포함하고 있지 않으니 suspend가 풀리지 않는거임). 그 후 컨트롤 c 누르면 모든 시그널 다 받아들이니까 시그인트 발생해서 핸들러 함수로 감. 컨트롤 c 계속 눌러도 인터럽트 계속 발생하다 컨트롤 백슬래쉬누르면 sigquit 발생해서 quitflag = 1되어서 while 문 빠져나오고 종료됨. quitflag는 최초에 0으로 셋팅된거임.
22. *시험나옴*. 23pge에 항상 부모가 먼저 캐릭터를 출력하게 만들려면 동기화를 시켜줘야 함. 이떄 signal을 사용. child는 부모 시그널 핸들러를 그대로 받아들임. 시그널 핸들러를 상속을 하지만 이 두 개는 서로 메모리상에서 독립임. 즉 변수를 서로 공유할 수 없음. parent는 동기화 시 global flag를 사용. 부모가 부모 스스로 시그널을 바꾸는게 아니고 자식이 바꿔주는 거임. child는 부모에게 시그널 보낼때 process id를 사용해야하니 ppid를 쓰고, 부모는 fork 할때의 리턴값인 pid 사용. 
23. 이 코드에서는 자식이 항상 먼저 실행됨 부모는 wait_child(); 로 기다리게 하니까. 
24. sigflag가 0이면 기다려야 함. sigusr1, sigusr2를 블락킹해주면서 초기화 해줌. newmask에 sigusr1, 2가 있음. wait_parent에서 제로마스크로 셋팅한건 모든 시그널을 받아들인다는거임. 결국은 sigusr만 받아들일 수 있음. wait_parent, wait_child 마지막엔 oldmask로 복구함. main 함수는 사진 찍었음.
25. 실행유닛이 하나면 suspend가 되면 더 이상 수행 될 수 없음. 그래서 signal을 이용해서 실행 유닛을 멀티플하게 만들자는 뜻임. 

==Thread part 1== 
- 다시 돌아옴. 
18. ~넘어감. 
- 뮤텍스 건 thread가 두 번 호출되면 자기자신도 못 들어가니 데드락에 걸림.
- 해결방안은 락건만큼 카운트 후 언락해주거나 os가 락이 걸린 상태에서 락을 또 걸려고 하면 에러를 띄워버리는 방법이 있기는 함. 근데 락을 건 애가 언락을 하는게 가장 바람직함.
19. 여기서 스레드는 3개다 (메인도 있으니). 스레드 제어가 안된게 문제임(동기화문제). 
25. 스레드 종료의 3가지 방법.
27. join시키면 detachedstate에 둔다. 
28. 리턴하거나 exit하거나 똑같은 값을 리턴해줌
29. foo의 공간은 스택에 있다. 메인에서 마지막에 fp로 읽으려고 할 때 쓰레기값을 읽음. 
31. malloc 써야함. 넘아감
32. 임계영역에서 cancel 당하면 위험하다. 
33. all or nothing이다. 
34. 동기화 캔슬 : 동기화 지점에서만 캔슬이 가능함. 뮤텍스 건드리는 시점에 캔슬이 발생하면 큐잉됨. 
35. 임계영역 들어갈땐 uncancelable하게 해줘야함(Asynchornous라면).
36. testcancel 만나는 순간 지연된 캔슬을 처리해줌. while 무한 루프 안에 틈틈이 심어줌.
38. 옛날 state 복구

==Thread part 2==
10. free 한 걸 스레드가 다시 접근하면 seg fault.
13. 이미 해제된 포인터를 destroy하면 문제가 발생할 수도 있다. 
14. 락한거에 또 락을 하면 데드락. try lock은 락 실패하면 다음 코드로 넘어감. 
21. 세 명이 동시에 접근하는걸 컨트롤하는건 semaphore이고 값을 업데이트 하는건 mutex로 함. 
23. 그 예. lock - sem_post - unlock 구조가 일반적임. 시험엔 안 나옴. 

==Thread part 3== **시험 안나옴**
22. locked in read mode에서는 읽는 행위만 함으로 여러 스레드가 들어와도 노상관. 
34. pthread_cond_wait로 기다릴땐 락을 풀어주고 기다리는 거임. 그리고 시그널 받고 재개될 때는 다시 락을 걺. **이건 시험 나옴**

==Thread part 4==
2. signal desposition : 시그널 핸들러의 주소. 스레드는 이 signal desposition을 프로세스 내에서 스레드들 간 공유됨. 마지막 두 줄 -> 시그널도 핸들러로 만드는 이유임. 개인별로 시그널을 블락할 수는 있지만 핸들러는 공유함. 
4. 스레드가 기다리는 시그널을 명시해서 기다릴 수 있음. 
5. 관심있는 시그널은 sigwait 하기 전에 블록해야함. 스레드 4개가 시그널을 보내도 실제론 하나만 취급하는 듯 (프로세스 입장에서 시그널을 처리하니까). 비동기적으로 발생하는 시그널이 sigwait에서 합류하니 동기적으로 변환됨. 다른 스레들들이 특정 시그널을 시그마스크 해놓으면 시그널을 호출한 스레드만 처리되고 나머지 스레드들은 영향 받지 않는 듯.  
- 만약 스레드가 `sigwait` 호출 전에 시그널을 블록하지 않으면, 해당 스레드가 `sigwait`를 호출하기 전에 시그널이 도착할 수 있습니다. 이 경우, 시그널이 도착하더라도 스레드가 아직 `sigwait`를 호출하지 않았기 때문에 시그널을 놓칠 수 있습니다. 시그널을 놓치면 `sigwait`가 시그널을 기다려도 영원히 대기 상태에 빠질 수 있습니다. 시그널을 블록하면 스레드가 `sigwait`를 호출하기 전에 해당 시그널이 도착하더라도 큐에 보관됩니다. 이렇게 하면 `sigwait`를 호출했을 때 큐에 보관된 시그널을 안전하게 처리할 수 있습니다.특정 시그널을 블록하면, 이 시그널은 해당 스레드에서 처리되지 않고 대기 상태가 됩니다. 이 시그널은 큐에 보관되며, `sigwait`가 호출되면 큐에 보관된 시그널을 처리할 수 있습니다. `sigwait`는 호출된 시그널 집합에서 시그널이 도착할 때까지 대기합니다. 블록된 시그널이 도착하면 `sigwait`는 이 시그널을 감지하고 처리할 수 있습니다.
- 4개의 스레드 중 하나가 fork하면 자식에게 나머지 스레드들을 복사해줄지 안 할지 정의해야함.  -> 보통 fork 한 스레드 하나만 카피함
7. 오른편에 sigmask는 &mask를 블록하는거고 왼편의 sigwait는 &mask를 허용하는 것과 동일함. 즉 sigmask로 블락해놓은 값이 왼편에 가면 허용되는 거임. 
8. 메모리 콘텐츠에 변화 없는 한 자식과 부모는 공간을 공유함. write가 되는 순간 별도의 메모리를 갖는듯. 만약 자식이 exec하면 공유해도 문제가 안 생기는 듯. 
9. 만약 스레드 4가 포크해서 자식을 만드는데 스레드3이 lock과 관련해 동작해도 4의 자식은 스레드3를 복사하지 않았기에 원하는 동작이 안됨. 그래서 fork 이전에 lock state를 clean up해야 함. 
11. 넘어감
12. atfork로 prepare 호출되면 lock1, 2가 락 걸림. sleep(2)은 부모가 먼저 실행되는걸 막는 용도(스레드 함수가 우선되게). `pthread_atfork`는 `fork`처럼 자식 프로세스를 생성하지 않습니다. 대신, `pthread_atfork`는 `fork` 함수가 호출될 때 실행될 준비/후처리 핸들러를 등록하는 함수입니다. 코드 쳐보기
13. 자식이 락의 카피를 unlock하려고 할 때 새 메모리가 자식에게 할당됨. (copy on write)

==Socket Programming 1==
2. 포트 하나에는 프로세스가 하나만 붙음. 하나의 IP는 여러개의 프로세스를 가질 수 있음. 소켓 하나하나가 파일임. 
6. ~수업함. SOCK_STREAM : TCP, SOCK_DGRAM : UDP임.

==Socket Programming 2== *시험안나옴*
2. 수업함
3. 구조체 크기 같게 만들기 위해 padding 넣음. 
5. 참고만
6. 클라이언트는 시스템으로 부터 포트를 받아오는게 효율적이기에 bind() 작업이 없음. 
7. 넘어감
8. tcp에서는 receiver가 flow control한다. 
13. 시험안나옴
15. ~넘어감. 빅엔디언은 1, 2 순이고 리틀이면 2, 1순임. 

==Socket Programming 3==
1. 소켓 기본 구성 요소 : ip, port. 
- 연결지향형 : 서버는 항상 먼저살아서 자신의 주소와 포트를 bind한 후 listen한다. 그럼 다른 프로세스는 서버가 bind한 주소 및 포트를 쓸 수 없음. 클라는 socket만들고 연결 요청하면 서버가 accept 해줌. tcp 소켓은 한 프로세스만 연결됨(1대1 통신만 가능 - 각 클라의 주소를 서버는 카피해서 각자 그 주소로 전달해줘야함). broadcast하려면 1:n인 udp 사용.  
22. **시험나옴** 클라하나가 들어오면 서버는 링크만들고 통신 그 후 다른 클라들어오면 기존꺼 끊고 새로운 얘랑 연결인듯. 클라 요청들어와서 accept 할 때마다 자식을 만듦. 자식은 부모의 파일디스크립트테이블도 상속받음. figure 4.5가 listen 연결끊고 connfd만 연결되어서 다른 애들을 listen 할수 있음. 자식을 fork 한건 4.16그림임. 서버 종료되면 connfd를 close함 (connfd는 자식과 클라간 연결이 되는거라 부모는 진작에 끊어야하는듯). 자식의 listenfd는 부모와 연결된거니 끊어줘야하고 부모의 connfd는 클라와 연결된거니 끊어줘야함 (자식과 클라를 연결시키는게 목적이니).    
23. 좀비로 만들지 않기 위해 signal(SIGCHLD, sig_chld) 호출함.






리눅스에서 Ctrl+C를 누르는 것은 프로세스에 SIGINT 시그널을 보내는 것과 동일합니다. 따라서 프로세스는 SIGINT 시그널을 수신하고 이에 대응하여 해당 시그널을 처리하는 시그널 핸들러를 등록해야 합니다.

- `sem_close`: 파일 디스크립터를 닫습니다. 이것은 해당 세마포어를 더 이상 사용하지 않을 때 호출됩니다. 만약 다른 프로세스에서 여전히 세마포어를 사용 중이라면 세마포어 자체는 파괴되지 않습니다. 다른 프로세스가 모두 세마포어를 닫은 후에야 파괴됩니다.
- `sem_unlink`: 이름이 있는 세마포어를 제거합니다. 이것은 세마포어를 더 이상 사용하지 않을 때 호출됩니다. 만약 해당 세마포어를 여전히 사용 중인 다른 프로세스가 있다면, 그 프로세스가 모두 세마포어를 닫은 후에야 제거됩니다.
- 문제되는 코드에서는 `main` 함수에서 `pthread_join` 함수를 호출하기 전에 세마포어를 닫고(unlink) 있습니다. 그러나 세마포어를 닫으면서 세마포어를 사용하는 스레드가 여전히 해당 세마포어를 참조하려고 시도하기 때문에 Segmentation Fault가 발생합니다.
- 세마포어 다 지우기 : find /dev/shm -name 'sem.*' -exec rm -f {} \;

공유 메모리의 키(key) 값은 해당 공유 메모리를 생성할 때 사용되는 식별자입니다. 키 값이 0x00000000인 경우에는 시스템에서 예약된 공유 메모리 세그먼트를 나타내며, 일반적으로 사용자가 직접 만든 것이 아닙니다. 반면에 사용자가 직접 생성한 공유 메모리의 키 값은 시스템에서 할당되는데, 보통 0x00000f62와 같은 형태를 갖습니다. 따라서 키 값이 0x00000f62인 공유 메모리는 사용자가 만든 것일 가능성이 높습니다.

`pthread_cond_wait`와 `pthread_cond_signal`는 POSIX 스레드(POSIX threads, pthreads) 라이브러리에서 제공하는 조건 변수(condition variable)를 사용한 스레드 동기화 기법입니다. 이 함수들은 스레드 간의 협력을 도와주는 중요한 역할을 합니다.

`pthread_cond_wait(&newDeposit, &lock);`
`pthread_cond_wait` 함수는 조건 변수를 이용해 스레드를 대기 상태로 전환합니다. 이 함수는 두 가지 주요 기능을 수행합니다:
1. 지정된 조건 변수가 신호를 받을 때까지 스레드를 대기 상태로 만듭니다.
2. 대기하는 동안 주어진 뮤텍스(mutex)를 잠금 해제합니다.
동작 방식
1. **뮤텍스 잠금 해제**: `pthread_cond_wait`를 호출하면 스레드는 우선 현재 보유 중인 뮤텍스를 잠금 해제합니다.
2. **조건 변수 대기**: 스레드는 조건 변수가 신호를 받을 때까지 대기 상태로 들어갑니다. 이 대기 상태에서는 스레드는 실행을 중지하고, 다른 스레드가 뮤텍스를 사용할 수 있도록 합니다.
3. **뮤텍스 다시 잠금**: 조건 변수가 신호를 받아 대기 상태에서 깨어날 때, `pthread_cond_wait`는 스레드가 뮤텍스를 다시 잠그도록 합니다. 이후, 스레드는 임계 구역(critical section) 내의 작업을 계속 수행합니다.
- `pthread_mutex_lock(&lock);`: 뮤텍스를 잠가 다른 스레드가 `balance`에 접근하지 못하게 합니다.
- `while (balance < amount)`: 출금하려는 금액이 잔고보다 클 경우, 스레드는 조건 변수가 신호를 받을 때까지 대기합니다.
- `pthread_cond_wait(&newDeposit, &lock);`: 조건 변수가 신호를 받을 때까지 스레드는 대기 상태가 되며, 이 동안 뮤텍스를 잠금 해제합니다.
- 조건 변수가 신호를 받으면 뮤텍스를 다시 잠그고 `balance`에서 금액을 차감합니다.
- `pthread_mutex_unlock(&lock);`: 임계 구역의 작업을 마친 후 뮤텍스를 해제합니다.

`pthread_cond_signal(&newDeposit);`
`pthread_cond_signal` 함수는 조건 변수를 기다리고 있는 스레드 중 하나를 깨웁니다. 대기 중인 스레드가 여러 개일 경우, 그 중 하나만 선택되어 깨어납니다.
동작 방식
1. **조건 변수 신호**: `pthread_cond_signal`은 조건 변수를 신호하여 대기 중인 스레드 중 하나를 깨웁니다.
2. **뮤텍스 잠금 상태**: 깨어난 스레드는 `pthread_cond_wait`에 의해 다시 뮤텍스를 잠그고 나서 실행을 재개합니다.
- `pthread_mutex_lock(&lock);`: 뮤텍스를 잠가 다른 스레드가 `balance`에 접근하지 못하게 합니다.
- `balance += amount;`: 무작위 금액을 계좌에 입금합니다.
- `pthread_cond_signal(&newDeposit);`: 조건 변수를 신호하여 `pthread_cond_wait`에서 대기 중인 스레드 하나를 깨웁니다.
- `pthread_mutex_unlock(&lock);`: 뮤텍스를 해제하여 다른 스레드가 `balance`에 접근할 수 있게 합니다.
요약
- **`pthread_cond_wait`**: 조건 변수를 사용하여 스레드를 대기 상태로 전환하고, 뮤텍스를 잠금 해제합니다. 조건 변수가 신호를 받을 때 스레드는 뮤텍스를 다시 잠그고 대기에서 깨어납니다.
- **`pthread_cond_signal`**: 조건 변수를 신호하여 대기 중인 스레드 중 하나를 깨웁니다. 깨어난 스레드는 `pthread_cond_wait`에 의해 다시 뮤텍스를 잠그고 실행을 재개합니다.
이 함수를 사용함으로써 스레드 간의 협력을 통해 효율적으로 자원을 사용할 수 있으며, 특정 조건이 충족될 때까지 안전하게 대기할 수 있습니다.

**중요**
&lock과 &newDeposit은 다르다. lock은 뮤텍스 잠금/해제용이고 newDeposit은 조건변수로서 신호를 주고 받는 용이다. ??
`pthread_cond_wait`는 호출되면 뮤텍스를 잠금 해제하고 나중에 대기 상태에서 깨어날 때 자동으로 뮤텍스를 다시 잠급니다. 따라서 깨어난 스레드는 안전하게 임계 구역을 재진입할 수 있습니다.
정리하면
cond_wait 호출되면 unlock하고 신호 받을 때 까지 대기, lock이 해제 된 상태이기에 deposit에서 스레드가 lock을 걸고 signal을 보내고 unlock하고 종료. 그러면 wait는 lock을 다시 걸고 출금한 뒤에 마지막에 unlock 하고 종료. deposit에서 unlock해주기 전에는 lock이 걸린 상태이기에(처음의 depost-lock 때문), deposit 스레드가 끝나기 전에 cond wait가 깨어날 때 lock을 걸 수는 없는 듯


- 채팅프로그램 : asynchronous 하게 만들지 않고 임계영역 빠져나오면 cacnel 시키게 만들기. 여기서 발생하는 문제 테스트 해보기
- 해결방안 : 스레드가 임계영역에 들어가 세마포어를 획득한 상태에서 `pthread_cancel()`에 의해 종료되면, 세마포어가 반환되지 않은 상태로 남을 수 있습니다. 이를 방지하기 위해 `pthread_cleanup_push()`와 `pthread_cleanup_pop()`을 사용하여 정리 작업을 수행할 수 있습니다.

**chapter 1, 2, 3, 5**
- malloc()가 시스템콜 함수인 sbrk()를 호출해도 sbrk는 주소공간을 늘리고 줄일 뿐 memory management 기능은 없음. 이는 process가 관리하도록 맡김.   
- 실행파일 구조 : 명령라인인자+환경변수 - 스택(밑으로 자람) - (shared memory) - 힙(위로 자람) - 비초기화 데이터(bss) - 초기화된 데이터 - 텍스트
- 전역 array[100]은 비초기화 데이터 영역에 저장됨. malloc는 heap, shmid는 share memory. 함수는 stack. 
- 텍스트 영역만 프로세스간 공유 가능, 데이터영역(초기, 비초기), 힙, 스택은 공유 불가.
- ps -ef 하면 uid, pid, ppid, time 등을 알 수 있음. 유닉스의 1번 프로세스는 init 프로세스임(모든 프로세스의 부모). 2번은 kthreadd 프로세스(모든 스레드의 부모).
- ps -ef | grep "myfork" 치면 부모 프로세스가 누군지 보여줌
- push fp 하고 mov sp, fp 한 후 리턴 하기 전 mov fp, sp하고 pop fp한다. mov fp, sp는 sp = fp라는 뜻이고 fp를 pop시키면 스택 없어지는거임
- sp(스택포인터) : 기본적으로 함수가 호출될 때마다 전달한 인자와 정의한 지역(자동) 변수가 높은 주소부터 낮은 주소의 방향으로 차례대로 저장되는 구조이다. 이외에도 다른 함수를 호출할 때 복귀할 주소(다음 실행할 명령어의 주소), 프레임 포인터 및 보존되는 레지스터들이 스택에 저장된다. 스택 포인터는 함수 호출 시작부터 피호출 프로그램이 실행되는 단계 차례대로 저장되는 값들을 저장하기 위해 현 시점에서 저장할 메모리의 위치를 가리킨다.
- fp(프레임 포인터) : 함수 호출이 끝난다면 상위 호출로 돌아기전에 지역 변수에 할당한 자원을 파괴한 후 스택 포인터를 옮겨서 호출자가 함수를 호출하던 상황을 만들어야한다. 이 때, 프레임 포인터가 사용되는데 프레임 포인터는 호출자가 호출하던 시점의 스택 포인터를 저장하고 피호출 프로그램이 종료할 때 이 값을 이용하여 스택 포인터를 재조정하는데 사용한다.
- 함수가 호출되면 프레임 포인터는 호출된 함수의 스택 프레임의 시작 위치를 가리키도록 이동하고, 함수가 종료되면 다시 이전의 호출자의 스택 프레임을 가리키도록 이동합니다.
- 지역(automatic)변수는 스택에 저장되고 함수 완료시 제거됨. 전역변수들은 데이터 영역에 저장되고 끝까지 유지됨. static 변수들은 전역처럼 프로그램 수명 동안 메모리에 상주하고 함수나 블록 범위 벗어나도 값 유지됨 그 중 내부정적은 특정 함수 내에서만 접근 가능. 메인에서 func1에 선언된 static int cnt를 여러번 호출하면 값 누적됨. 외부정적은 특정 파일에 선언되고 다른 파일에서 접근 불가. 접근하려면 extern 사용. 해당 파일 내에서는 어디서든 접근 가능.
- high coupling : 모듈간 강력한 의존성, 유지 보수가 어렵고 확장이 제한될 수 있습니다. low coupling : 모듈이 서로 독립적, 하나의 모듈 변경이 다른 모듈에 미치는 영향력 적어 더 나은 설계 원칙으로 간주됨. 
- 정보 은닉의 원칙을 따르면서 모듈의 내부 요소들을 서로 관련시키고 cohension(응집력)을 높이는 것이 자연스러운 발전이라는 의미를 전달합니다.
- char * s = "hello world";  은 텍스트 영역에 상수로서 저장됨으로 값 바꿀 수 없다. 
- 메인함수에서 main(); 호출하면 스택오버플로우
- malloc는 항상 aligned된 메모리를 제공하는데 정렬되지 않은 메모리 주소를 가리키면 bus error 발생
- 메모리 부족으로 realloc이 실패할 수 있으니 temp에 realloc을 받고 ptr = temp로 해주기
- Ncurses Library 함수는 initscr(), endwin()사이에 위치

**chapter 11~18
- <sys/types.h>, <sys/ipc.h>, <sys/shm.h> 사용
- shmget(2018, 32, 0666|IPC_CREAT), shmat(id, 0, 0), shmctl(id, IPC_RMID, 0).
- ipcs -m : 유저 정보가 출력됨(객체의 공유메모리를 보여줌). 
- ipcrm -m 4 : 4번 아이디가 삭제됨. 
- shmdt(chatInfo); 연결 해제
- 메인에서 child의 pid 값은 0, parent는 양수임. getpid() 자체는 현재 프로세스의 pid를 반환하기에 둘 다 양수임.
- The vfork function creates the new process without copying the address space of the parent into the child. vfork guarantees that the child runs first, until the child calls exec or exit. 부모 프로세스의 주소 공간을 복사하는 대신에 자식 프로세스가 부모 프로세스의 주소 공간을 공유함.
- fork로 자식생성하면 부모의 변수들을 자식이 물려받고 if문 안에서 그 변수를 증가 시켜도 부모 프로세스에는 영향을 못 끼치나 vfork로 하면 영향 끼침.
- wait' 함수는 호출자가 자식 프로세스가 종료될 때까지 블록될 수 있습니다. 즉, 호출자가 'wait' 함수를 호출하면 자식 프로세스가 종료될 때까지 기다리게 됩니다. waitpid는 특정 pid의 자식만 기다릴 수 있음.
- 지역변수 int status에 대해 부모가 wait(&status); 하면 status에 자식이 종료됐는지 여부를 알 수 있게 되고WIFEXITED(status)를 if문에 걸어 1이면 자식의 정상종료인걸 앎. if ((returned = waitpid(pid, &status, 0)) != pid) 이면 wait error이고 else 후 returned == 0이 참이면 자식이 종료되지 않았다는 뜻임.
- 부모 프로세스가 자식 프로세스의 종료 상태를 수집하지 않으면, 해당 자식 프로세스는 좀비 프로세스가 됩니다. 부모 프로세스가 종료되면 자식 프로세스는 고아 프로세스가 됩니다. 이 경우, init 프로세스 (PID 1)가 새로운 부모 프로세스가 됩니다.
- Compile시-lpthread 옵션 추가
- 세마포어 wait(P)는 세마포어를 감소시킴. 0보다 작은 상태였다면 양수 될 때 까지 대기하고 0보다 크거나 같으면 wait는 세마포어 1 감소시키고 진행. signal(V)은 세마포어 증가시키는데 이를 통해 다른 프로세스가 세마포어를 사용할 수 있도록 해줌. 
- sigint : ctrl c 입력 (포그라운드 프로세스 그룹에 있는 모든 프로세스에 전달됨. 
- sigquit : ctrl \ 입력
- sighup : terminal 연결 끊기게 될 때
- signal( SIGINT, SigInt_Handler ); signal 발생하면 sigint로 가고 이는 sigint_handler가 관리.
- 보통 운영체제에서는 Ready 상태로 복귀하는 프로세스들을 Queue (List) 형태로 관리합니다.
- ps -af : 모든 프로세스 풀 리스팅. ps -l : long format 으로 리스팅
- 표준출력을 파일 형태로 redirection 하면 부모 프로세스 영역에 printf("before fork") 파트가 버퍼링 되었고 fork 했을 때 자식 영역에 복사 되어서 두 번 호출 된 것임.
- fork로 상속되는 속성 : 현재 작업 디렉, 루트 디렉, 파일 생성 마스크, 시그널 마스크, 환경변수, open 된 파일 디스크립터, 프로세스 그룹 및 세션
- fork 후 달라지는 속성 : fork 함수의 리턴값, process id, 자식의 utime stime cutime 등은 0으로 초기화, pending된 알람과 시그널은 자식프로세스에선 초기화됨.
- fork() 후에 자식 프로세스와 부모 프로세스는 동일한 pc (혹은 ip) 레지스터 값을 가진다.
- 사용자가 정의한 함수 내부에서 vfork 호출하면 에러 발생 할 수 있음. 자식 프로세스가 리턴한 후 해당 사용자 정의 함수에 대한 스택프레임이 없기 떄문.
- `execle`은 환경 변수를 명시적으로 설정할 때 사용하고, `execlp`는 `PATH`에서 프로그램을 찾고, `execv`는 환경 변수를 사용하지 않고 프로그램을 실행할 때. execle("/bin/ls", "ls", "-l", NULL, envp);. execlp("ls", "ls", "-l", NULL);. execv("/bin/ls", args);.
- file discripter : 입출력 리소스를 나타내는 정수 (표준입력, 출력, 오류 - 0 , 1, 2).

**chapter 19, 25**
- IPC_CREAT 는 존재하지 않으면 생성하라는 옵션  
- IPC_EXCL 은 기존 공유 메모리가 있으면 -1을 리턴함.
- process 죽을때 ipc도 제거되진 않음. 필요하면 유저가 제거해줘야함 (공유메모리나 공유세마포어는 누가 접근할지 모르니 os가 제거 해주진 않음). process당 process control table (pcb)를 가짐 (더블링크드리스트로 구현됨). process가 죽으면 os가 이 링크들을 다 끊음. 나머지를 기다리게 하려면 semaphore 값들을 다 0으로 설정해놓으면 됨 (*시험* )
- IPC 테크닉 종류
- 1. 파이프라인 :표준 출력을 표준 입력으로 연결 (단방향의 문제점 가짐, 구현 편함)
- 2. 세마포어
- 3. 공유메모리
- 4. 메세지큐 (개수 제한이란 단점)
- 5. 네트워크를 통한 소켓 (서버-클라 두고 주소를 127.0.1인 자기자신에게 보내면 됨)
- ipc는 file system 와 달리 reference count(몇 개의 프로세스가 자신을 참조하는지)가 없어 삭제를 못 함. 모든 프로세스가 해당 공유 메모리를 해제할 때까지 메모리가 보존됩니다.
- 프로세스 종료한다해서 생성된 세마포어가 자동으로 없어지진 않음.
- `sem_wait` (P)함수는 세마포어를 기다리는 동안 현재 세마포어 값이 0보다 큰지 확인하고, 값이 0보다 크다면 값을 감소시키고 즉시 반환합니다. 세마포어 값이 0이라면 현재 스레드는 세마포어가 신호를 보낼 때까지 기다리게 됩니다.
- `sem_post` (V, signal)함수는 세마포어 값을 증가시킵니다. 이는 세마포어를 사용하는 다른 스레드나 프로세스가 세마포어를 기다리고 있을 때 그 중 하나를 깨우는 데 사용됩니다. 따라서 이 함수를 호출하면 세마포어를 기다리는 스레드나 프로세스 중 하나가 깨어나서 세마포어를 사용할 수 있게 됩니다.
- 꿀벌곰 문제에서 첫번쨰 예시 : 곰이 먼저 들어가면 P(full)에서 full이 0이기 때문에 계속 기다림. 꿀벌은 곰이 이미 mutex를 0으로 감소시켜놨기 때문에 들어가질 못함 -> dead lock. 두번째 예시 : full과 pot 둘 다 0이니 둘 다 기다리는 듯. test.c 확인하기
- V: violation. 시그 폴트가 생기면 현 메모리 상태를 저장하는 core 파일이 생성됨. SIGURG -  급한 메세지를 바로 처리할 수 있게끔 함.  유닉스는 kill을 명령어로도 주고 함수로도 줌. kill(1) : 명령어, kill(2) : 함수임. 
- mysigalarm.c :  ps -ef | grep "mysig" 하면 알림 보내는 mysig 파일 종료시킬수 있음. 
- real time : deadlinen 내에 끝마침을 보장해주는 것. 
- os를 정의하는 방식 : premptive / non premptive, real time / non real time
- utilization = busy time / 관측 시간. 완료된 task의 수와 같은 throughput이 좋아야 좋은 시스템이다. 
- repsonse time : 프로그램 시작~끝 시간. response itme을 줄이려면 thread를 사용하고 실행시간이 짧은것부터 시작시키는게 더 줄어듬. 
- 시그널 액션 3가지 ignore the signal, catch the signal, let the  default action 중 SIGKILL과 SIGSTOP은 root가 보내는거라 무시 못함.
- child가 죽을때 SIGCHLD 보냄. 이 시그널을 못 잡으면 zombie가 됨. SIGCONT : 중지된 시그널 재개. SIGABRT ; abort function이 호출. SIGALRM은 alarm function의 timer가 만료될 때 발생, SIGBUS는 implementation defined hw fault임. 
- SIGHUP : 목적은 컨트롤 터미널이나 연결된 프로세스의 종료를 알리는 것. 관리자는 설정 변경 후 `SIGHUP` 시그널을 해당 서비스에 보내어 새 설정을 적용하도록 요청하는 용도로 사용될 수도 있다.
- SIGSEGV : 프로세스가 잘못된 메모리 참조시 발생

**chapter 21~24**
- If one thread changes the value of a variable, for instance, the other thread subsequently will see the modified value. If one thread closes a file descriptor, other threads may not read from or write to that file descriptor
- 프로세스는 thread의 정보를 갖고 있는데 스레드가 죽어서 detach 할 때 detachsate를 사용함. thread가 차지한 자원을 돌려준다. By calling pthread_join, we automatically place a thread in the detached state so that its resources can be recovered.
- 스레드는 같은 프로세스id를 갖고 다른 thread id를 갖는다. 근데 리눅스에서는 pid가 다를 떄도 있음. 왜냐하면 스레드를 실행시킬 때 child 프로세스가 실행하도록 만들기 때문 (이건 옛날 얘기임).
- thread 종료 방법 : 정상적으로 return 후, pthread_exit으로 종료, 다른 스레드가 현재 실행 중인 스레드를 시그널로 종료.
- pthread_join 매개변수로 pthread_t thread 주면 해당 thread의 종료를 기다리도록 할 수 있음.
- pthread_cond_signal로 시그널 보내면 블록 되어 있던 스레드가 언블록됨. pthread_cond_broadcast하면 모든 블록된 애들을 언블록함. pthread_cond_wait하면 해당 스레드를 시그널 받을 때 까지 블록시킴.
- 즉, 스레드가 `pthread_cond_wait()` 함수를 호출하기 직전에는 반드시 그 스레드가 `pthread_mutex_lock()`으로 뮤텍스를 잠금 상태로 만들고 있어야 합니다. 그리고 시그널을 받으면 mutex_unlock을 해주면 됨.

- sem_init은 성공시 0 실패시 -1 반환.
- 이전 코드에서는 `sem_init`를 사용하여 프로세스 내에서만 사용되는 (즉, 프로세스 간 공유되지 않는) 세마포어를 초기화하려고 했습니다. 하지만 수정된 코드에서는 `sem_open`을 사용하여 이름 있는 세마포어를 생성하고 있습니다. 이름 있는 세마포어는 여러 프로세스 간에 공유될 수 있으며, 이는 공유 메모리를 사용하는 다중 프로세스 프로그램에서 특히 유용합니다. `sem_t semP;` 로 정의된 `semP`는 실제로 세마포어 객체 그 자체이며, 이를 `sem_open`으로 초기화하기 위해서는 포인터 형식으로 사용해야 합니다. 이는 `sem_open` 함수가 세마포어 객체에 대한 포인터를 반환하기 때문입니다. 그러므로, 올바른 접근 방식은 `semP`를 포인터로 선언하고 `sem_open` 함수를 사용하여 초기화하는 것입니다.

- join 해서 메인스레드의 종료를 막아야함. 
- 스레드함수에서 선언한 구조체 인스턴스는 pthread_exit의 인자로 main에게 넘겨줘도 main은 쓰레기값 읽음. 왜냐하면 스레드함수가 종료되면 스택에서 해당 인스턴스는 해제되니까. 그래서 malloc으로 구조체를 선언하거나 전역으로 선언해야함.
- 임계영역 들어갈땐 uncancelable하게 해줘야함(Asynchornous라면). testcancel 만나는 순간 지연된 캔슬을 처리해줌. while 무한 루프 안에 틈틈이 심어줌. pthread_cleanup_push() 로 exit될 때 자동으로 cleanup handler가 호출된다. pthread_cleanup_pop() 인자로 0을 주면 cleanup handler 호출되지 않는다.
- free 한 걸 스레드가 다시 접근하면 seg fault.
- pthread_mutex_destroy 호출 전에 free해서 malloc 사용한 포인터를 해제해버리면 이미 해제된 포인터를 destroy하는 문제 발생
- 락한거에 또 락을 하면 데드락. try lock은 락 실패하면 다음 코드로 넘어감 (일반 락은 락 획득할 때까지 기다려야하는데 얜 딴 일 할 수 있으니 이득임).
- pthread_cond_wait 호출 전에 mutex는 이미 락에 걸린 상태여야 함. 그리고 cond wait가 호출되면 mutex를 unlock 해주고 조건 변수는 블락됨. 나중에 signaled 돼서 깨어나면 다시 mutex를 lock 해주고 진행함. 
- 각 스레드는 고유의 시그널 마스크를 갖지만 signal disposition은 프로세스 내 모든 스레드가 공유함. 즉 각 스레드는 시그널을 독자적으로 블락시킬 수는 있으나 다른 스레드가 해당 시그널의 action을 변경하면 모두가 영향 받음.
- signals are delivered to a single thread in the process
- sigprocmask는 멀티쓰레드 프로세스에서 정의되지 않았기에 pthread_sigmask를 써야함
- 스레드는 sigwait(스레드가 해당 시그널을 기다리도록 함)을 호출하기 전에 해당 시그널을 block해야함. 예를 들어, 스레드 A가 시그널을 블록하지 않은 상태에서 `sigwait`를 호출하고 있을 때, 시그널이 도착하면 스레드 B가 먼저 그 시그널을 처리할 수 있습니다. 그러면 스레드 A는 시그널이 도착하지 않은 것처럼 계속 기다리게 됩니다. 즉 레이스컨디션 방지의 목적. 만약 스레드가 `sigwait` 호출 전에 시그널을 블록하지 않으면, 해당 스레드가 `sigwait`를 호출하기 전에 시그널이 도착할 수 있습니다. 이 경우, 시그널이 도착하더라도 스레드가 아직 `sigwait`를 호출하지 않았기 때문에 시그널을 놓칠 수 있습니다. 시그널을 놓치면 `sigwait`가 시그널을 기다려도 영원히 대기 상태에 빠질 수 있습니다. 
- 여러 스레드가 sigwait으로 특정 시그널을 기다린다면 시그널이 도착하면 그들 중 하나의 스레드가 return 받음. 비동기적으로 발생하는 시그널이 sigwait에서 합류하니 동기적으로 변환되는 장점이 있음. 즉 시그널이 발생한 경우 시그널을 처리하기 위한 실행 지점은 sigwait이 됨. 
- 전역 sigset_t mask;에 대해 main에서 sigemptyset(&mask) 은 시그널 집합을 빈 상태로 초기화합니다. 모든 시그널이 제거됨 그 후에 sigaddset(&mask, SIGINT 와 SIGQUIT);은 특정 시그널을 시그널 집합에 추가 후 pthread_sigmask(SIG_BLOCK, &mask, NULL); 는 메인 스레드에서 SIGINT와 SIGQUIT 시그널을 블록함. 스레드 함수에서는 무한 루프에서 sigwait로 시그널 기다리는 상황.
- 즉 메인 함수에서 `SIGINT` 시그널을 블로킹함으로써, `SIGINT`가 발생하더라도 메인 스레드가 이를 처리하지 않습니다. 대신, 시그널이 발생하면 `pthread_create`로 생성된 새 스레드에서 `sigwait`를 통해 시그널을 처리할 수 있게 됩니다. 이를 통해 시그널 핸들링을 특정 스레드에서 수행하도록 제어할 수 있습니다. 메인 스레드에서 시그널을 블로킹하지 않으면, 시그널이 발생했을 때 어떤 스레드가 이를 처리할지 예측할 수 없습니다. 메인 스레드에서 시그널을 블로킹하면, 새로 생성된 스레드에서만 시그널을 처리하게 되어 경쟁 조건을 방지할 수 있습니다. *thread4 - 7pge*
- 만약 스레드 4가 포크해서 자식을 만드는데 스레드3이 lock과 관련해 동작해도 4의 자식은 스레드3를 복사하지 않았기에 원하는 동작이 안됨. 그래서 fork 이전에 lock state를 clean up해야 함. pthread_atfork()를 사용해서 구현. `pthread_atfork`는 `fork`처럼 자식 프로세스를 생성하지 않습니다. `pthread_atfork` 함수는 `fork` 함수가 호출될 때 실행되는 핸들러들을 등록하는 데 사용됩니다. 이 함수는 다중 스레드 환경에서 `fork`를 호출할 때 발생할 수 있는 잠재적인 문제를 해결하는 데 도움을 줍니다. `fork` 호출 시, 등록된 핸들러가 호출되는 순서는 다음과 같습니다 프리어크 핸들러 (prepare handler) : `fork`가 호출되기 **전**에 실행됩니다. 포스트포크 핸들러 (parent handler): `fork`가 호출된 **후**, 부모 프로세스에서 실행됩니다. 포스트포크 핸들러 (child handler): `fork`가 호출된 **후**, 자식 프로세스에서 실행됩니다. 자식이 락의 카피를 unlock하려고 할 때 새 메모리가 자식에게 할당됨. (copy on write)
- 참고 : fork로 자식생성하면 부모의 변수들을 자식이 물려받고 if문 안에서 그 변수를 증가 시켜도 부모 프로세스에는 영향을 못 끼치나 vfork로 하면 영향 끼침.

- kill 1은 명령어, kill 2는 함수. 시그널 죽었는지 살았는지 확인할 때 0 씀. 
- ignore할 수 없는 signal은 sigkill 과 sigstop임.
- child가 죽을때 SIGCHLD 보냄. 이 시그널을 못 잡으면 zombie가 됨. SIGCONT : 중지된 시그널 재개. SIGHUP : 목적은 컨트롤 터미널이나 연결된 프로세스의 종료를 알리는 것. 
- void (* signal(int signo, void (* func)(int))) (int); `signal` 함수는 특정 시그널에 대한 핸들러를 설정하기 위해 사용됩니다. 함수 포인터를 사용하여 시그널 핸들러를 지정합니다. 반환 값은 이전에 설정된 시그널 핸들러입니다.
- 시그널을 처리하는 동안 시그널을 queuing 힘. signal은 reliable해야 함. 시그널을 등록하려는 순간에 또다른 시그널이 날라오면 처리가 안됨. 그래서 그 시그널이 오지 못하도록 블락 시켜야 함. 그래서 시그널을 등록하기전에 bit mask를 막아둬서 동기화 시켜야함.
- while 조건으로 sig_int_flag로만 단순히 체크하면 아토믹하지 않기에 무한히 대기해버릴 수가 있음.
- Reentrant functions : 일반적으로 시그널이 발생하면 현 프로세스의 context 정보를 저장하고 시그널 핸들러를 실행시킨 후 종료하면(instead of calling exit or longjmp) 보관된 프로세스의 context를 리로드하며 재개함.
- malloc 중에 시그널 발생해서 해당 시그널 처리하고 다시 malloc으로 재진입하면 문제가 생김 (포인터 사용은 보통 critical section임).
- 메인과 시그널 핸들러에서 같은 함수를 호출하면 포인터 문제가 발생할 수 있음.
- 비지역적분기 : longjmp(setjmp로 저장된 실행 상태로 돌아감, buffer에 정수값 넣음), setjmp(현재의 실행 상태를 저장함, jmp_buf buffer를 인자로 받음). `setjmp`는 `longjmp`에 의해 호출되면 0이 아닌 값을 반환합니다. 만약 그냥 직접 호출된 경우는 0을 반환함.
- longjmp 호출시 메모리에 저장된 변수들은 값유지, cpu 레지스터에 저장된 변수들은 setjmp 설정 시의 값으로 복원됨. 최적화 옵션 줘서 컴파일 하지 않는 경우 레지스터 변수 외의 변수는 다 메모리에 할당됨. 최적화 하는 경우에는 volatile 변수만 메모리에 할당하고 나머지는 최대한 레지스터에 할당함. 단, 레지스터에 저장됨을 보장하진 x.
- 옵션 안 주면 int는 메모리에 저장, register int는 운이 좋으면 레지스터에 저장됨, volatile은 메모리에 저장. 
- 옵션을 안 주면 : int 값유지, register int 값유지 or 복원, volatile int는 값유지 
- 옵션을 주면 : int 복원, register int 복원. volatile int는 값유지
- 즉 optimize하면 volatile만 값유지가 보장됨. 
- signal set을 사용하기 전에 sigemptyset을 호출해야함. sigaddset은  시그널을 set에 등록함
- `sigprocmask(int how, const sigset_t *set, sigset_t *oset)` 에서 다음 `how` 값에 따라 `sigprocmask`의 동작이 다르다.
- `SIG_BLOCK` : set에 등록된 signal들의 block을 설정한다.
- `SIG_UNBLOCK` : set에 등록된 signal들의 block을 해제한다.
- `SIG_SETMASK` : set에 등록된 signal들을 block 하도록 설정하고 set에 등록되지 않은 signal들의 block은 해제한다.
- `SIG_BLOCK`과 `SIG_SETMASK`의 차이는 `SIG_BLOCK`은 `sigprocmask` 사용 이전에 block 하던 signal들과 set에 등록한 signal들을 같이 block을 하지만, `SIG_SETMASK`은 set에 등록된 signal들만 block 한다는 차이점이 있다. `oset`은 `sigprocmask`를 사용하기 이전에 block 하던 signal들의 정보를 담을 `sigset_t*`이다. 담고 싶지 않다면 `null`값을 주면 된다. 만약 `set`의 값이 null값인데 `oset`의 값이 설정되어 있다면, 지금 block 하도록 설정된 signal들의 집합을 `oset`에 담아서 주는 일 말고 다른 일은 하지 않는다. [sigprocmask을 사용하여 signal block 하기 (tistory.com)](https://tempdev.tistory.com/40)
- sigprocmask(SIG_BLOCK,&mask,&prev); 이렇게 막고 sigprocmask(SIG_SETMASK,&prev,0); 이렇게 푼다.
- sigpending은 전달이 막혀 펜딩된 시그널을 리턴함.
-  시그널 핸들러에 선언된 `signal(SIGQUIT, SIG_DFL)`은 `SIGQUIT` 시그널에 대한 기본 동작을 복원하여 사용자가 프로그램을 종료할 수 있도록 함. 즉 컨트롤 슬래쉬 눌렀을 때 또 내가 만든 시그널 핸들러로 들어오는게 아니라 정상적으로 종료되도록 되돌리는거임
- 컨트롤 백슬래쉬를 10번 눌러도 한 번만 실행됨. 그 이유는 시그널 핸들러를 처리하는 동안 새로운 백슬래쉬(시그널)가 여러개 들어와도 블락 시키기 때문임. 즉 시그널은 큐잉이 불가함. 시그널이 발생하면 시그널 핸들러는 지금 발생한 시그널을 프로세스의 시그널 mask에 등록함. 그래서 동일한 시그널의 연속적 발생해도 현재 실행중인 시그널 핸들러가 간섭 받지 않게 됨. 시그널 핸들러 처리가 완료되면 해당 시그널의 mask 값을 이전상태로 되돌려 놓음.
- 시그널핸들러 정상 완료 전에 longjmp 해버리면 문제생기니 sigsetjmp(buffer에 현재 시그널 마스크를 갖는 정수 savemask를 저장)와 siglongjmp(저장된 시그널 마스크를 복원함)를 씀.
- `pr_mask`는 시그널 마스크를 출력하는 사용자 정의 함수입니다
- part4 - 14pge에 pause 에서 무한 대기 중에 sigusr1은 알람 시그널을 받으면 5초대기하고 siglongjmp 호출하면 if문에 들어가면 양수 값이니 진입가능함. set과 jmp를 바꾸면 점프할 상태가 저장되지 않은 상태에서 점프를 시도하게 되어 프로그램이 예상대로 동작하지 않게 됩니다. 
- `pause()` 함수는 프로세스가 시그널을 받을 때까지 대기하는데 사용됩니다. 이 함수는 호출된 후에 시그널을 받을 때까지 실행을 멈추고, 시그널을 받으면 해당 시그널 핸들러가 실행됩니다
- sigsuspend(const sigset_t * sigmask) 는 인자의 해당 시그널이 발생할 때까지 프로세스는 중지되고 있음. 만약 시그널이 잡히고 그 핸들러가 종료되면 sigsuspend는 sigsuspend를 부르기 이전의 값으로 시그널 마스크를 셋팅함. 
- sigsuspend로 suspend된 상태에서는 sigint가 발생해도 계속 suspend됨 (그 사이 sigint 핸들러가 수행되긴함). sigsuspend가 종료되어야 sigint를 처리하고 종료됨.
- 즉 프로그램은 크리티컬 영역에 진입하기 전에 `SIGINT` 시그널을 블록하고, `SIGUSR1` 시그널을 기다린 후에 크리티컬 영역을 벗어나기 전에 `SIGINT` 시그널을 다시 허용합니다.
- 20pge kill -SIGINT 8221을 입력해야함. kill -USR1 8221 하면 sigusr1을 죽이는거니 바로 종료되어버림 이전 예시는 sigusr1의 핸들러가 있으니 동작했는데 이 코드엔 없으니 sigint를 kill해야하나봄(어쨌든 이것도 SIGUSR을 사용한거니까).  <<= 아니고 ./a.out 한 뒤 그냥 컨트롤 c 누르면 종료됨. *사용자가 Ctrl+C를 눌러 `SIGINT`가 발생하면, 비록 `SIGINT`가 블록된 상태이지만 `sigsuspend`는 모든 시그널로 인해 중단될 수 있습니다. `sigsuspend`가 중단된 후 블록된 `SIGINT` 시그널이 처리되어 시그널 핸들러가 호출됩니다. 이는 `sigsuspend`가 특정 시그널(`SIGUSR1`)을 기다리더라도 다른 시그널(`SIGINT`)로 인해 중단될 수 있기 때문입니다. `sigsuspend`가 반환된 후, 블록된 시그널이 처리되기 때문에 `sig_int` 핸들러로 넘어가는 것입니다.*
- while (quitflag == 0) sigsuspend(&zeromask); `sigsuspend`는 반환되기 전에 발생한 시그널을 처리하기 위해 시그널 핸들러를 실행합니다. `zeromask`이기 때문에 모든 시그널이 허용된 상태에서 시그널 핸들러가 실행됩니다. 시그널 핸들러가 실행되고 나면 `sigsuspend`는 원래의 시그널 마스크로 복원됩니다. 이 경우, 원래의 시그널 마스크는 `SIGQUIT`이 블록된 상태입니다. 코드를 `while(quitflag == 0) sigsuspend(&newmask);`로 변경하면 프로그램의 동작이 어떻게 달라지는지 설명하겠습니다. 먼저, `sigsuspend(&newmask);`는 `newmask`로 지정된 시그널 마스크를 사용하여 프로세스를 일시 중지시키는데, `newmask`는 `SIGQUIT`이 포함된 시그널 집합입니다. 이를 통해 `newmask`를 사용하면 `SIGQUIT`이 블록된 상태로 일시 중지하게 됩니다.
- 정리 : `sigsuspend(&waitmask)` 함수는 `waitmask`에 포함되지 않은 시그널은 블록하지 않습니다. 따라서 `waitmask`에 포함되지 않은 시그널은 여전히 해당 프로세스에 전달됩니다. 따라서 SIGUSR1 이외의 시그널이 발생하더라도 프로그램은 종료되지 않고 계속 대기합니다. suspend를 빠져나오면 이전 시그널 마스크를(SIGINT를) 복구한다. 그래서 sigint가 찍힘
- 특정 시그널을 블록하면 해당 시그널이 발생했을 때 시그널 핸들러가 호출되지 않고, 대신 시그널이 대기열에 들어가게 됩니다. 블록된 시그널은 프로세스가 블록을 해제할 때까지 대기열에 남아 있으며, 그 후에야 시그널 핸들러가 호출됩니다. 이렇게 함으로써 프로세스는 특정 시그널을 일시적으로 무시하거나 처리를 지연시킬 수 있습니다.
- SIGQUIT으로 마스킹 (시그큇을 막음). quitflag == 0이면 계속기다리는데 이때 zeromask(아무것 블락하지 않은 마스크 상태를 가짐)는 모든 시그널을 받아들인다는 뜻. 그 후 컨트롤 c 누르면 모든 시그널 다 받아들이니까 시그인트 발생해서 핸들러 함수로 감. 컨트롤 c 계속 눌러도 인터럽트 계속 발생하다 컨트롤 백슬래쉬누르면 sigquit 발생해서 flag값 변경의로 인해 while 문 빠져나오고 종료됨. 
- *즉 suspend(A)라고 하면 A상태로 프로세스를 마스킹 하는거임 만약 A가 sigint를 블록하는 마스크라면 sigint가 발생하면 suspend해서 sigint 시그널 핸들러로 들어갈 수 없음. 근데 sigint가 아닌 sigquit 같은게 들어오면 sigquit이 suspend 이전에 블록 되었다 하더라도 suspend는 sigint만 블록하니 노상관이라 블록하지 않거니와 시그널 하나가 들어왔으니 suspend는 종료되는 거임. suspend가 종료되면 이전 마스크 상태를 복원함(sigquit이 블록된 마스크를 복원).*
- `wait_child`와 `wait_parent`가 호출되기 전 `TELL_WAIT`로 `SIGUSR1`과 `SIGUSR2`를 블록시키는 이유는 다음과 같습니다
1. **동기화**: `wait_child`와 `wait_parent`는 두 프로세스가 서로의 작업을 기다리는 데 사용됩니다. 만약 부모나 자식 프로세스가 `wait_child` 또는 `wait_parent`를 호출하기 전에 해당 시그널을 받게 된다면, 원하는 동작이 이루어지지 않을 수 있습니다. 시그널을 블록시킴으로써, 부모와 자식 프로세스는 서로의 작업을 완료하기 전까지 다른 작업을 하지 않도록 보장됩니다.
2. **시그널 충돌 방지**: 만약 `SIGUSR1` 또는 `SIGUSR2` 시그널을 블록하지 않는다면, 부모나 자식 프로세스가 시그널 핸들러에 진입할 때 다른 시그널이 발생하여 시그널 핸들러가 중단되는 경우가 발생할 수 있습니다. 이는 예기치 않은 동작을 유발할 수 있습니다. 따라서 해당 시그널을 블록함으로써 시그널 핸들러가 중단되는 것을 방지할 수 있습니다.
- int kill(pid_t pid, int sig); `kill` 함수는 특정 프로세스나 프로세스 그룹에 시그널을 보내는 데 사용됩니다. 일반적으로 다음과 같은 동작을 합니다: 단일 프로세스에 시그널 보내기: 특정 PID를 가진 프로세스에 시그널을 보냅니다. 프로세스 그룹에 시그널 보내기: 음수 PID를 사용하여 프로세스 그룹에 시그널을 보냅니다. 시그널 보내기 없음: 시그널 번호를 0으로 설정하여 시그널을 보내지 않고 해당 프로세스가 존재하는지 확인할 수 있습니다.
- 정리 : zeromask로 suspend 시켜놨기 때문에 SIGUSR1이나 SIGUSR2 아무거나 발생하면 suspend는 해제됨. 부모가 TELL_CHILD 호출하면서 인자로 pid인 자식 프로세스 id를 주면 kill(pid, SIGUSR1)을 통해 자식 프로세스에 시그널을 발생시키면 시그널핸들러 발동하고 sigflag가 1이 되어서 suspend 되어있던 자식이 무한 루프 빠져나와 메세지 보낼 수 있는거임. 그 반대도 같은 원리임.
- sigsuspend 함수는 인자로 지정한 시그널 집합에 설정된 시그널들로  프로세스의 시그널 마스크를 교체하고, 블록되지 않은 시그널이 도착할 때까지 프로세스의 수행을 멈추고 기다립니다. 시그널이 도착하면 프로세스의 시그널 마스크는 이전 설정으로 되돌아 갑니다.


- 4장 17, 18pge : multi level index는 indirect pointers를 쓴다. data block 영역에 indirect block을 할당함. 이 블락은 direct pointers를 저장하는데 사용. 4KB blocks과 4byte disk address로는 하나의 block에 1024 address를 저장할 수 있음. block의 데이터를 포인팅하는게 아니라 inode를 만들어서 indirect block을 포인팅하게 함. inode가 포함하는 direct pointer가 12개일 때 파일 사이즈 커져서 indirect block 할당해야하면 max file size는 (12 + 1024) x 4KB이고 더 커져서 double indirect block(allocate a block that sotres pointers to indirect blocks)이면 max file size는 (12 + 1024 + 1024^2) x 4KB가 된다. 즉 direct pointer는 4kb 크기 데이터 블록을 가리킬수있으니 12 x 4kb이고 indirect block이 가리킬 수 있는 데이터 블록의 포인터 수를 계산해보면 indirect block size / pointer size = 1024개가 나옴. 각 포인터는 4kb 크기 데이터 블록을 가리킬 수 있으니 1024 x 4kb임. 따라서 (12 + 1024) x 4KB가 나옴.
- 21pge : 12 direct blocks = 4KB x 12 = 48KB. 1 block = 4KB. one indirect block size = 4KB. sizeof(pointer) = 4byte. 1 direct block(4KB) / 4bytes per pointer = 1024 pointer. the maximum file size pointed by 1 indirect block = 1024 pointers x 4KB per one pointer = 4096KB = 4MB. 즉 인디렉트 블록이 가질 수 있는 포인터 수는 1024개 이고 이 포인터들이 4KB의 데이터 블록의 크기를 포인팅 할 수 있으니 둘을 곱해서 4MB가 나옴.
- the maximum file size pointed by 1 double indirect block은 이전에 구한 4MB에 1024 포인터 개수만큼 곱하면 4GB나옴. 만약 triple indirect block이면 4TB이고 the maximum file size 는 48kb + 4mb + 4GB + 4TB가 됨.
- 즉 the maximum file size pointed by 1 indirect block은 4MB이고 the maximum file size는 4MBㄴ + 4KB이다.
- 4장 27pge 다시보기

- 두 프로세스가 동일한 파일을 열면 두 프로세스 각각의 파일 포인터가 각각 갖게 되는 파일테이블을 포인팅하게 되며 그 파일테이블의 v-node 포인터는 동일한 v-node 테이블을 가리키고 그 내부는 동일한 i-node를 가리킴.
- 한 프로세스가 동일한 파일을 오픈하면 프로세스 내 두 파일 포인터가 각각의 fd로 동일한 파일테이블을 가리키고 이는 동일한 vnode, inode 가리킴
- 부모와 차일드는 같은 파일 오프셋을 가리킴.
- 부모 프로세스와 자식 프로세스가 동일한 파일 디스크립터를 공유하는 경우, 동기화 없이 동시에 파일에 쓰기를 시도하면 출력이 섞일 수 있다는 것을 설명합니다.
- 부모와 자식은 같은 파일 디스크립터를 공유하지만, 파일 디스크립터 테이블의 항목은 독립적입니다.
- 같은 파일 테이블 항목을 참조하므로, 파일 오프셋과 파일 상태 플래그는 공유됩니다.

- pread : read한 뒤 lseek 한 것과 동일. 이 두 오퍼레이션 역할을 아토믹하게 수행함으로 중간에 인터럽트가 발생할 요소가 없는게 장점, 파일 오프셋의 변경이 없음(read와의 차이). 즉 다중 스레드 환경에서 여러 스레드가 같은 파일 디스크립터를 공유하는 경우, `pread`를 사용하면 파일 오프셋을 이동하지 않고 특정 위치에서 데이터를 읽을 수 있으므로, 동기화가 더 쉬워집니다.
- open과 creat 사이에 다른 프로세스가 파일을 생성하면 동기화 문제가 발생할 수 있음. 만약 다른 프로세스가 파일 생성하고 write했는데 뒤늦게 creat 먹으면 write된거 지워짐. 
- 각 `open` 호출은 새로운 파일 디스크립터를 생성하지만, 이 디스크립터들은 동일한 파일 테이블 엔트리와 v-노드 엔트리를 가리킴으로써 동일한 파일을 참조하게 됩니다. 이 메커니즘을 통해 파일 디스크립터는 독립적인 파일 오프셋과 상태를 유지하면서도 동일한 파일에 접근할 수 있습니다. (동일한 파일테이블에 두 개의 파일테이블 엔트리가 존재함, 그리고 하나의 inode 테이블에 하나의 inode 엔트리만 존재함)
- 동일한 파일을 여러 번 열 때 각 파일 디스크립터는 독립적인 파일 오프셋과 상태 플래그를 갖습니다. 따라서 하나의 파일 디스크립터에서 파일 오프셋이나 상태를 변경해도 다른 파일 디스크립터에는 영향을 미치지 않습니다. 
- sync : 쓰기 작업으로 수정된 블록을 큐잉함, 즉 모든 수정된 블록을 디스크에 비동기적으로 기록함 (disk에 기록 될 때 기다리지 않음, 이 함수는 시스템 데몬에 의해 주기적으로 호출됨, 커널의 블록 버퍼를 주기적으로 flushing 해줌을 보장함). fsync : 파일 디스크립터 fd로 지정된 파일의 모든 수정된 데이터를 디스크에 동기화합니다. 데이터가 디스크에 안전하게 기록될 때까지 반환되지 않습니다. 즉, 호출한 프로그램은 디스크 기록이 완료될 때까지 기다립니다. 데이터 블록뿐만 아니라 파일의 메타데이터(예: 파일 크기, 수정 시간 등)도 디스크에 기록합니다. fdatasync : fsync와 같은 동작을 하나, 파일의 데이터 블록을 디스크에 기록하지만, 파일의 메타데이터는 동기화하지 않습니다. 단, 파일 크기 변경과 같은 데이터 일관성에 영향을 미칠 수 있는 메타데이터는 동기화합니다. 
- fd = open("/dev/fd/0", mode) 와 fd = dup(0)은 동일.
- dup()을 하면 하나의 프로세스에서 두 개의 fd1, fd2가 하나의 파일테이블의 하나의 엔트리를 가리킴.

- client 들어오면 서버의 listenfd에 연결요청 보냄. 서버는 connfd와 클라를 연결시키며 accept함. 그리고 서버는 자식을 fork하는데 자식은 부모의 fd를 상속받음. 즉 클라와 자식의 connfd도 연결됨. 이때 부모는 클라와 기존에 연결된 connfd를 끊고 자식도 listenfd에 부모와 연결된 링크를 끊으면 클라와 자식만 독립적으로 연결됨.
- `sem_wait` (P)함수는 세마포어를 기다리는 동안 현재 세마포어 값이 0보다 큰지 확인하고, 값이 0보다 크다면 값을 감소시키고 즉시 반환합니다. 세마포어 값이 0이라면 현재 스레드는 세마포어가 신호를 보낼 때까지 기다리게 됩니다.
- `sem_post` (V, signal)함수는 세마포어 값을 증가시킵니다. 이는 세마포어를 사용하는 다른 스레드나 프로세스가 세마포어를 기다리고 있을 때 그 중 하나를 깨우는 데 사용됩니다. 따라서 이 함수를 호출하면 세마포어를 기다리는 스레드나 프로세스 중 하나가 깨어나서 세마포어를 사용할 수 있게 됩니다.





